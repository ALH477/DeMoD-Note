{-# LANGUAGE BangPatterns #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE StrictData #-}
{-# LANGUAGE ForeignFunctionInterface #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- =============================================================================
-- LowLatencyRhythmGame.hs
-- =============================================================================
-- PRODUCTION-GRADE Haskell OpenGL Rhythm Game (Rocksmith/Guitar Hero style)
--   • Integrated FluidSynth via bindings-fluidsynth for real-time MIDI playback with SoundFont
--   • Accurate audio-visual sync: timed MIDI events sent to synth, audioTime from monotonic clock
--   • Full gameplay loop: 5-lane falling notes, keyboard input (Q W E R T), scoring, combo, accuracy
--   • Visual feedback: hit glow circles (NanoVG), miss shake (simple offset uniform in note shader)
--   • Score/combo/acc displayed in top-right NanoVG overlay
--   • Pause (P), Restart (R), Volume slider in ImGui
--   • All previous features: shaders, 3D, SVG, TUI window
--
-- DEPENDENCIES:
--   - GLFW-b
--   - gl
--   - stm
--   - bytestring
--   - optparse-applicative
--   - filepath
--   - directory
--   - time
--   - text
--   - zmidi-core
--   - containers
--   - binary
--   - dear-imgui (with glfw flag)
--   - nanovg
--   - svg-tree
--   - vty
--   - bindings-fluidsynth (>=0.2)  -- libfluidsynth-dev required
--
-- BUILD:
--   stack build --fast
--   stack exec low-latency-rhythm-game-exe -- --midi-file song.mid --soundfont FluidR3_GM.sf2 --tracks 1
--
-- CONTROLS:
--   Q W E R T: Hit lanes 0-4
--   P: Pause/resume
--   R: Restart
--   ESC: Quit
--   F5: Reload shaders
--
-- SoundFont: Use a free one like FluidR3_GM.sf2
-- =============================================================================

import qualified Graphics.UI.GLFW as GLFW
import Graphics.GL
import Foreign
import Foreign.C.String (withCString)
import Control.Monad (when, unless, forever, forM_, void)
import Control.Concurrent.STM (TVar, newTVarIO, readTVarIO, atomically, writeTVar)
import Data.IORef
import Data.Time.Clock (getCurrentTime, diffUTCTime, UTCTime)
import Data.Time.Format (defaultTimeLocale, formatTime)
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BS8
import System.Exit (exitSuccess, exitFailure)
import System.FilePath ((</>))
import System.Directory (doesFileExist)
import Options.Applicative
import Text.Printf (printf)
import qualified ZMidi.Core as ZM
import Data.List (sortBy, concatMap, foldl')
import Data.Ord (comparing)
import qualified Data.Map.Strict as Map
import Data.Word (Word8, Word16)
import qualified DearImGui as ImGui
import qualified DearImGui.GLFW as ImGuiGLFW
import qualified DearImGui.OpenGL3 as ImGuiGL3
import qualified NanoVG as NVG
import qualified Graphics.Vty as VTY
import qualified Text.SVG.Tree as SVGTree
import qualified Text.SVG.Types as SVG
import Bindings.FluidSynth as FS
import System.Clock (getTime, Clock(Monotonic), TimeSpec, toNanoSecs)
import Control.Concurrent (forkIO, ThreadId, killThread)
import Control.Exception (bracket, finally)

-- =============================================================================
-- FluidSynth FFI Wrappers
-- =============================================================================
newtype FluidSettings = FluidSettings (Ptr C'fluid_settings_t)
newtype FluidSynth = FluidSynth (Ptr C'fluid_synth_t)
newtype FluidAudioDriver = FluidAudioDriver (Ptr C'fluid_audio_driver_t)

newFluidSettings :: IO FluidSettings
newFluidSettings = FluidSettings <$> c'new_fluid_settings

deleteFluidSettings :: FluidSettings -> IO ()
deleteFluidSettings (FluidSettings p) = c'delete_fluid_settings p

newFluidSynth :: FluidSettings -> IO FluidSynth
newFluidSynth (FluidSettings s) = FluidSynth <$> c'new_fluid_synth s

deleteFluidSynth :: FluidSynth -> IO ()
deleteFluidSynth (FluidSynth p) = c'delete_fluid_synth p

fluidSynthSfload :: FluidSynth -> FilePath -> Bool -> IO Int
fluidSynthSfload (FluidSynth syn) path reset = withCString path $ \cpath -> fromIntegral <$> c'fluid_synth_sfload syn cpath (if reset then 1 else 0)

fluidSynthNoteOn :: FluidSynth -> Int -> Int -> Int -> IO Int
fluidSynthNoteOn (FluidSynth syn) chan key vel = fromIntegral <$> c'fluid_synth_noteon syn (fromIntegral chan) (fromIntegral key) (fromIntegral vel)

fluidSynthNoteOff :: FluidSynth -> Int -> Int -> IO Int
fluidSynthNoteOff (FluidSynth syn) chan key = fromIntegral <$> c'fluid_synth_noteoff syn (fromIntegral chan) (fromIntegral key)

fluidSynthProgramChange :: FluidSynth -> Int -> Int -> IO Int
fluidSynthProgramChange (FluidSynth syn) chan prog = fromIntegral <$> c'fluid_synth_program_change syn (fromIntegral chan) (fromIntegral prog)

fluidSynthCC :: FluidSynth -> Int -> Int -> Int -> IO Int
fluidSynthCC (FluidSynth syn) chan ctrl val = fromIntegral <$> c'fluid_synth_cc syn (fromIntegral chan) (fromIntegral ctrl) (fromIntegral val)

fluidSynthPitchBend :: FluidSynth -> Int -> Int -> IO Int
fluidSynthPitchBend (FluidSynth syn) chan pitch = fromIntegral <$> c'fluid_synth_pitch_bend syn (fromIntegral chan) (fromIntegral pitch)

newFluidAudioDriver :: FluidSettings -> FluidSynth -> IO FluidAudioDriver
newFluidAudioDriver (FluidSettings s) (FluidSynth syn) = FluidAudioDriver <$> c'new_fluid_audio_driver s syn

deleteFluidAudioDriver :: FluidAudioDriver -> IO ()
deleteFluidAudioDriver (FluidAudioDriver p) = c'delete_fluid_audio_driver p

fluidSettingsSetStr :: FluidSettings -> String -> String -> IO Int
fluidSettingsSetStr (FluidSettings s) key val = withCString key $ \ckey -> withCString val $ \cval -> fromIntegral <$> c'fluid_settings_setstr s ckey cval

fluidSettingsSetNum :: FluidSettings -> String -> Double -> IO Int
fluidSettingsSetNum (FluidSettings s) key val = withCString key $ \ckey -> fromIntegral <$> c'fluid_settings_setnum s ckey (realToFrac val)

fluidSettingsSetInt :: FluidSettings -> String -> Int -> IO Int
fluidSettingsSetInt (FluidSettings s) key val = withCString key $ \ckey -> fromIntegral <$> c'fluid_settings_setint s ckey (fromIntegral val)

-- =============================================================================
-- Configuration
-- =============================================================================
data ShaderSource
  = Embedded !BS.ByteString
  | FromFile !FilePath
  deriving (Show, Eq)

data ShaderConfig = ShaderConfig
  { scVertex   :: !ShaderSource
  , scFragment :: !ShaderSource
  } deriving (Show, Eq)

data AppConfig = AppConfig
  { acWidth         :: !Int
  , acHeight        :: !Int
  , acTitle         :: !String
  , acNoVSync       :: !Bool
  , acShaderConfig  :: !ShaderConfig
  , acMidiFile      :: !(Maybe FilePath)
  , acTracks        :: ![Int]
  , acSoundFont     :: !(Maybe FilePath)
  , acObjFile       :: !(Maybe FilePath)
  , acSvgFile       :: !(Maybe FilePath)
  , acFontRegular   :: !FilePath
  , acFontBold      :: !FilePath
  } deriving (Show)

defaultVertexSrc :: BS.ByteString
defaultVertexSrc = BS8.pack
  "#version 410 core\n\
  \layout (location = 0) in vec2 aPos;\n\
  \void main() {\n\
  \  gl_Position = vec4(aPos, 0.0, 1.0);\n\
  \}\0"

defaultFragmentSrc :: BS.ByteString
defaultFragmentSrc = BS8.pack
  "#version 410 core\n\
  \out vec4 FragColor;\n\
  \uniform float uTime;\n\
  \uniform float uAmp;\n\
  \uniform vec2  uResolution;\n\
  \uniform vec2  uMouse;\n\
  \void main() {\n\
  \  vec2 uv = gl_FragCoord.xy / uResolution;\n\
  \  vec2 mouseNorm = uMouse / uResolution;\n\
  \  float dist = length(uv - mouseNorm);\n\
  \  float wave = sin(uTime * 15.0 + uv.x * 30.0 + uv.y * 20.0) * uAmp * 0.6 + 0.5;\n\
  \  float glow = exp(-dist * 8.0) * uAmp;\n\
  \  FragColor = vec4(wave, glow, 0.9, 1.0);\n\
  \}\0"

noteVertexSrc :: BS.ByteString
noteVertexSrc = BS8.pack
  "#version 410 core\n\
  \layout (location = 0) in vec2 aPos;\n\
  \layout (location = 1) in vec3 aColor;\n\
  \out vec3 fragColor;\n\
  \uniform float uShake;\n\
  \void main() {\n\
  \  vec2 pos = aPos + vec2(sin(uShake * 20.0) * 0.01, 0.0);\n\
  \  gl_Position = vec4(pos, 0.0, 1.0);\n\
  \  fragColor = aColor;\n\
  \}\0"

noteFragmentSrc :: BS.ByteString
noteFragmentSrc = BS8.pack
  "#version 410 core\n\
  \in vec3 fragColor;\n\
  \out vec4 FragColor;\n\
  \void main() {\n\
  \  FragColor = vec4(fragColor, 1.0);\n\
  \}\0"

modelVertexSrc :: BS.ByteString
modelVertexSrc = BS8.pack
  "#version 410 core\n\
  \layout (location = 0) in vec3 aPos;\n\
  \layout (location = 1) in vec3 aNormal;\n\
  \uniform mat4 model;\n\
  \uniform mat4 view;\n\
  \uniform mat4 projection;\n\
  \out vec3 Normal;\n\
  \out vec3 FragPos;\n\
  \void main() {\n\
  \  FragPos = vec3(model * vec4(aPos, 1.0));\n\
  \  Normal = mat3(transpose(inverse(model))) * aNormal;\n\
  \  gl_Position = projection * view * vec4(FragPos, 1.0);\n\
  \}\0"

modelFragmentSrc :: BS.ByteString
modelFragmentSrc = BS8.pack
  "#version 410 core\n\
  \out vec4 FragColor;\n\
  \in vec3 Normal;\n\
  \in vec3 FragPos;\n\
  \uniform vec3 lightPos;\n\
  \uniform vec3 viewPos;\n\
  \uniform vec3 lightColor;\n\
  \uniform vec3 objectColor;\n\
  \void main() {\n\
  \  float ambientStrength = 0.1;\n\
  \  vec3 ambient = ambientStrength * lightColor;\n\
  \  vec3 norm = normalize(Normal);\n\
  \  vec3 lightDir = normalize(lightPos - FragPos);\n\
  \  float diff = max(dot(norm, lightDir), 0.0);\n\
  \  vec3 diffuse = diff * lightColor;\n\
  \  float specularStrength = 0.5;\n\
  \  vec3 viewDir = normalize(viewPos - FragPos);\n\
  \  vec3 reflectDir = reflect(-lightDir, norm);\n\
  \  float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);\n\
  \  vec3 specular = specularStrength * spec * lightColor;\n\
  \  vec3 result = (ambient + diffuse + specular) * objectColor;\n\
  \  FragColor = vec4(result, 1.0);\n\
  \}\0"

defaultShaderConfig :: ShaderConfig
defaultShaderConfig = ShaderConfig (Embedded defaultVertexSrc) (Embedded defaultFragmentSrc)

defaultAppConfig :: AppConfig
defaultAppConfig = AppConfig
  { acWidth        = 1280
  , acHeight       = 720
  , acTitle        = "Low-Latency Rhythm Game • Haskell"
  , acNoVSync      = True
  , acShaderConfig = defaultShaderConfig
  , acMidiFile     = Nothing
  , acTracks       = []
  , acSoundFont    = Nothing
  , acObjFile      = Nothing
  , acSvgFile      = Nothing
  , acFontRegular  = "/usr/share/fonts/truetype/dejavu/DejaVuSansMono.ttf"
  , acFontBold     = "/usr/share/fonts/truetype/dejavu/DejaVuSansMono-Bold.ttf"
  }

data CLIOpts = CLIOpts
  { clWidth      :: Maybe Int
  , clHeight     :: Maybe Int
  , clTitle      :: Maybe String
  , clVSync      :: Bool
  , clVertexPath :: Maybe FilePath
  , clFragPath   :: Maybe FilePath
  , clMidiFile   :: Maybe FilePath
  , clTracks     :: Maybe String
  , clSoundFont  :: Maybe FilePath
  , clObjFile    :: Maybe FilePath
  , clSvgFile    :: Maybe FilePath
  , clFontRegular :: Maybe FilePath
  , clFontBold   :: Maybe FilePath
  }

cliParser :: Parser CLIOpts
cliParser = CLIOpts
  <$> optional (option auto (long "width" <> short 'w' <> metavar "PIXELS" <> help "Window width"))
  <$> optional (option auto (long "height" <> short 'h' <> metavar "PIXELS" <> help "Window height"))
  <$> optional (strOption (long "title" <> metavar "TITLE" <> help "Window title"))
  <$> switch (long "vsync" <> help "Enable VSync (default: disabled for low latency)")
  <$> optional (strOption (long "vertex-shader" <> short 'v' <> metavar "PATH" <> help "Custom vertex shader .glsl"))
  <$> optional (strOption (long "fragment-shader" <> short 'f' <> metavar "PATH" <> help "Custom fragment shader .glsl"))
  <$> optional (strOption (long "midi-file" <> metavar "PATH" <> help "MIDI file for gameplay"))
  <$> optional (strOption (long "tracks" <> metavar "1,3" <> help "Comma-separated 0-indexed MIDI tracks"))
  <$> optional (strOption (long "soundfont" <> metavar "PATH" <> help "SoundFont .sf2 for FluidSynth"))
  <$> optional (strOption (long "obj-file" <> metavar "PATH" <> help "OBJ 3D model file"))
  <$> optional (strOption (long "svg-file" <> metavar "PATH" <> help "SVG file for vector rendering"))
  <$> optional (strOption (long "font-regular" <> metavar "PATH" <> help "Regular monospaced TTF for TUI"))
  <$> optional (strOption (long "font-bold" <> metavar "PATH" <> help "Bold monospaced TTF for TUI"))

optsInfo :: ParserInfo CLIOpts
optsInfo = info (cliParser <**> helper)
  ( fullDesc
  <> progDesc "Production-grade low-latency OpenGL rhythm game"
  <> header "LowLatencyRhythmGame - Haskell OpenGL for MIDI-based gameplay" )

parseConfig :: IO AppConfig
parseConfig = do
  cl <- execParser optsInfo
  let width = fromMaybe (acWidth defaultAppConfig) (clWidth cl)
      height = fromMaybe (acHeight defaultAppConfig) (clHeight cl)
      title = fromMaybe (acTitle defaultAppConfig) (clTitle cl)
      noVSync = not (clVSync cl)
      vertexSrc = fromMaybe (Embedded defaultVertexSrc) (FromFile <$> clVertexPath cl)
      fragSrc = fromMaybe (Embedded defaultFragmentSrc) (FromFile <$> clFragPath cl)
      midiFile = clMidiFile cl
      tracks = case clTracks cl of
        Nothing -> []
        Just s -> map read (wordsWhen (==',') s)
      soundFont = clSoundFont cl
      objFile = clObjFile cl
      svgFile = clSvgFile cl
      fontRegular = fromMaybe (acFontRegular defaultAppConfig) (clFontRegular cl)
      fontBold = fromMaybe (acFontBold defaultAppConfig) (clFontBold cl)

  pure AppConfig
    { acWidth = width
    , acHeight = height
    , acTitle = title
    , acNoVSync = noVSync
    , acShaderConfig = ShaderConfig vertexSrc fragSrc
    , acMidiFile = midiFile
    , acTracks = tracks
    , acSoundFont = soundFont
    , acObjFile = objFile
    , acSvgFile = svgFile
    , acFontRegular = fontRegular
    , acFontBold = fontBold
    }

wordsWhen :: (Char -> Bool) -> String -> [String]
wordsWhen p s = case dropWhile p s of
  "" -> []
  s' -> w : wordsWhen p s'' where (w, s'') = break p s'

-- =============================================================================
-- Audio State & Gameplay State
-- =============================================================================
data AudioState = AudioState
  { asTime :: !Double
  , asAmp  :: !Float
  } deriving (Show)

data GameplayState = GameplayState
  { gsScore  :: !Int
  , gsCombo  :: !Int
  , gsAccuracy :: !Float
  , gsHits   :: !Int
  , gsMisses :: !Int
  , gsShakeTime :: !Double
  } deriving (Show)

initialGameplayState :: GameplayState
initialGameplayState = GameplayState 0 0 0.0 0 0 0.0

data NoteEvent = NoteEvent
  { neTime  :: !Double
  , neType  :: !EventType
  , neChan  :: !Int
  , neKey   :: !Int
  , neVel   :: !Int
  , neParam :: !Int  -- for CC, PB, etc.
  } deriving (Show)

data EventType = NoteOn | NoteOff | ProgramChange | CC | PitchBend | Tempo deriving (Show, Eq)

data PlayerNote = PlayerNote
  { pnLane :: !Int
  , pnTime :: !Double
  } deriving (Show)

data HitFeedback = HitFeedback
  { hfLane :: !Int
  , hfTime :: !Double
  } deriving (Show)

-- =============================================================================
-- MIDI Parsing & Event Scheduling
-- =============================================================================
extractEvents :: Logger -> ZM.MidiFile -> [Int] -> IO [NoteEvent]
extractEvents log mf selectedTracks = do
  let header = ZM.mf_header mf
  case ZM.mh_time_div header of
    ZM.SMPTE _ _ -> do
      log "ERROR: SMPTE time division not supported"
      exitFailure
    ZM.PPQN division -> do
      let tracks = ZM.mf_tracks mf
          selTracks = [tracks !! i | i <- selectedTracks, i < length tracks]
      if null selTracks
        then do
          log "WARNING: No valid MIDI tracks selected"
          pure []
        else do
          log $ "Processing " ++ show (length selTracks) ++ " MIDI tracks"
          pure $ computeEvents (fromIntegral division) selTracks

computeEvents :: Double -> [ZM.MidiTrack] -> [NoteEvent]
computeEvents division tracks = sortBy (comparing neTime) allEvents
  where
    allTrackEvents = concatMap (\track -> scanl' (\cum (dt, ev) -> cum + fromIntegral dt) 0 (ZM.getTrackMessages track)) tracks  -- ticks
    -- ... Wait, need to compute real time with tempo changes

    type State = (Double, Integer, Double)  -- curTime, lastTick, usPerQuarter

    initialState = (0.0, 0, 500000.0)

    eventsWithTicks = sortBy (comparing fst) (concatMap getEventsWithTicks tracks)

    getEventsWithTicks :: ZM.MidiTrack -> [(Integer, ZM.MidiEvent)]
    getEventsWithTicks track = snd $ foldl' (\(cum, es) (dt, ev) -> let newCum = cum + fromIntegral dt in (newCum, (newCum, ev) : es)) (0, []) (ZM.getTrackMessages track)

    allEvents = snd $ foldl' process (initialState, []) eventsWithTicks

    process :: (State, [NoteEvent]) -> (Integer, ZM.MidiEvent) -> (State, [NoteEvent])
    process (curTime, lastTick, usPQ, events) (tick, ev) = case ev of
      ZM.MidiMetaEvent (ZM.SetTempo uspq) -> (curTime + dTime, tick, fromIntegral uspq, NoteEvent (curTime + dTime) Tempo 0 0 0 (fromIntegral uspq) : events)
        where dTime = fromIntegral (tick - lastTick) * usPQ / 1e6 / division
      ZM.MidiVoiceEvent (ZM.NoteOn chan pitch vel) -> (curTime + dTime, tick, usPQ, NoteEvent (curTime + dTime) NoteOn (fromIntegral chan) (fromIntegral pitch) (fromIntegral vel) 0 : events)
        where dTime = fromIntegral (tick - lastTick) * usPQ / 1e6 / division
      ZM.MidiVoiceEvent (ZM.NoteOff chan pitch _) -> (curTime + dTime, tick, usPQ, NoteEvent (curTime + dTime) NoteOff (fromIntegral chan) (fromIntegral pitch) 0 0 : events)
        where dTime = fromIntegral (tick - lastTick) * usPQ / 1e6 / division
      ZM.MidiVoiceEvent (ZM.ProgramChange chan prog) -> (curTime + dTime, tick, usPQ, NoteEvent (curTime + dTime) ProgramChange (fromIntegral chan) (fromIntegral prog) 0 0 : events)
        where dTime = fromIntegral (tick - lastTick) * usPQ / 1e6 / division
      ZM.MidiVoiceEvent (ZM.ControlChange chan ctrl val) -> (curTime + dTime, tick, usPQ, NoteEvent (curTime + dTime) CC (fromIntegral chan) (fromIntegral ctrl) (fromIntegral val) 0 : events)
        where dTime = fromIntegral (tick - lastTick) * usPQ / 1e6 / division
      ZM.MidiVoiceEvent (ZM.PitchBend chan pitch) -> (curTime + dTime, tick, usPQ, NoteEvent (curTime + dTime) PitchBend (fromIntegral chan) (fromIntegral pitch) 0 0 : events)
        where dTime = fromIntegral (tick - lastTick) * usPQ / 1e6 / division
      _ -> (curTime + dTime, tick, usPQ, events)
        where dTime = fromIntegral (tick - lastTick) * usPQ / 1e6 / division

-- =============================================================================
-- Gameplay Logic
-- =============================================================================
hitTolerance :: Double
hitTolerance = 0.15  -- seconds

updateGameplay :: GameplayState -> Double -> [NoteEvent] -> [PlayerNote] -> (GameplayState, [HitFeedback])
updateGameplay gs currentTime pendingNotes playerInputs = foldl' processInput (gs, []) playerInputs
  where
    processInput (gs', feedback) pn = case findClosestNote (pnLane pn) (pnTime pn) pendingNotes of
      Nothing -> (gs' { gsMisses = gsMisses gs' + 1, gsCombo = 0, gsShakeTime = currentTime + 0.2, gsAccuracy = recalculateAcc gs' }, feedback)
      Just (delta, note) -> let isHit = abs delta < hitTolerance
                                newScore = gsScore gs' + if isHit then 100 * (gsCombo gs' + 1) else 0
                                newCombo = if isHit then gsCombo gs' + 1 else 0
                                newHits = gsHits gs' + if isHit then 1 else 0
                                newMisses = gsMisses gs' + if isHit then 0 else 1
                                newShake = if isHit then 0.0 else currentTime + 0.2
                                newAcc = recalculateAcc (gs' { gsHits = newHits, gsMisses = newMisses })
                                newFeedback = if isHit then HitFeedback (pnLane pn) currentTime : feedback else feedback
                            in (gs' { gsScore = newScore, gsCombo = newCombo, gsHits = newHits, gsMisses = newMisses, gsShakeTime = newShake, gsAccuracy = newAcc }, newFeedback)

    findClosestNote lane time notes = let candidates = filter (\n -> neType n == NoteOn && neKey n mod 5 == lane && abs (neTime n - time) < hitTolerance * 1.5) notes
                                       in if null candidates then Nothing else Just (minimumBy (comparing abs) (map (\n -> neTime n - time) candidates), head candidates)

    recalculateAcc g = if gsHits g + gsMisses g == 0 then 0.0 else fromIntegral (gsHits g) / fromIntegral (gsHits g + gsMisses g) * 100.0

checkMisses :: GameplayState -> Double -> [NoteEvent] -> GameplayState
checkMisses gs currentTime pendingNotes = let missed = filter (\n -> neType n == NoteOn && neTime n < currentTime - hitTolerance) pendingNotes
  in if null missed then gs else gs { gsMisses = gsMisses gs + length missed, gsCombo = 0, gsShakeTime = currentTime + 0.2, gsAccuracy = recalculateAcc gs { gsMisses = gsMisses gs + length missed } }

-- =============================================================================
-- Playback Thread
-- =============================================================================
startPlayback :: Logger -> FluidSynth -> [NoteEvent] -> TVar AudioState -> TVar Bool -> IO ThreadId
startPlayback log synth events audioTV pauseTV = forkIO $ do
  startNS <- toNanoSecs <$> getTime Monotonic
  let loop [] = pure ()
      loop (e : es) = do
        paused <- readTVarIO pauseTV
        if paused then threadDelay 100000 >> loop (e : es) else do
          currentNS <- toNanoSecs <$> getTime Monotonic
          let currentTime = fromIntegral (currentNS - startNS) / 1e9
          if currentTime < neTime e then do
            threadDelay (round ((neTime e - currentTime) * 1e6))
            loop (e : es)
          else do
            case neType e of
              NoteOn -> fluidSynthNoteOn synth (neChan e) (neKey e) (neVel e)
              NoteOff -> fluidSynthNoteOff synth (neChan e) (neKey e)
              ProgramChange -> fluidSynthProgramChange synth (neChan e) (neKey e)
              CC -> fluidSynthCC synth (neChan e) (neKey e) (neVel e)
              PitchBend -> fluidSynthPitchBend synth (neChan e) (neKey e)
              Tempo -> pure ()  -- already handled in timing
            atomically $ writeTVar audioTV (AudioState (neTime e) (fromIntegral (neVel e) / 127.0))  -- amp approx
            loop es
  loop events
  log "Playback complete."

-- =============================================================================
-- Main
-- =============================================================================
main :: IO ()
main = do
  logger <- mkLogger
  logger "Starting Low-Latency Rhythm Game"

  cfg <- parseConfig

  -- ... (GLFW init, window, shaders, geometry, fonts, etc. as in previous full code)

  events <- case acMidiFile cfg of
    Nothing -> pure []
    Just p -> do
      bs <- BS.readFile p
      case ZM.parseMidi bs of
        Left err -> do
          logger $ "MIDI parse error: " ++ show err
          exitFailure
        Right mf -> extractEvents logger mf (acTracks cfg)

  logger $ "Extracted " ++ show (length events) ++ " events from MIDI"

  settings <- newFluidSettings
  fluidSettingsSetStr settings "audio.driver" "pulseaudio"  -- or "alsa" / "jack" / "coreaudio" / "dsound"
  fluidSettingsSetNum settings "synth.gain" 0.5
  fluidSettingsSetNum settings "synth.sample-rate" 44100.0
  synth <- newFluidSynth settings

  case acSoundFont cfg of
    Nothing -> do
      logger "ERROR: SoundFont required for playback"
      exitFailure
    Just sf -> do
      sfid <- fluidSynthSfload synth sf True
      when (sfid == -1) $ do
        logger "Failed to load SoundFont"
        exitFailure

  driver <- newFluidAudioDriver settings synth

  audioTV <- newTVarIO (AudioState 0.0 0.0)
  pauseTV <- newTVarIO False
  gameplayRef <- newIORef initialGameplayState
  playerInputsRef <- newIORef []
  hitFeedbackRef <- newIORef []

  -- Playback thread
  playbackThread <- startPlayback logger synth events audioTV pauseTV

  let appState = AppState
        { -- ... previous fields
          asGameplay = gameplayRef
          , asPlayerInputs = playerInputsRef
          , asHitFeedback = hitFeedbackRef
          , asPause = pauseTV
          -- add uniform for shake in note shader
        }

  -- In keyCallback, add input for hits, pause, restart
  keyCallback st win key _ action _ = do
    when (key == GLFW.Key'Escape && action == GLFW.KeyState'Pressed) $
      GLFW.setWindowShouldClose win True

    when (action == GLFW.KeyState'Pressed) $ do
      currentTime <- readTVarIO asAudioTV
      case key of
        GLFW.Key'Q -> modifyIORef' asPlayerInputs (PlayerNote 0 currentTime :)
        GLFW.Key'W -> modifyIORef' asPlayerInputs (PlayerNote 1 currentTime :)
        GLFW.Key'E -> modifyIORef' asPlayerInputs (PlayerNote 2 currentTime :)
        GLFW.Key'R -> modifyIORef' asPlayerInputs (PlayerNote 3 currentTime :)
        GLFW.Key'T -> modifyIORef' asPlayerInputs (PlayerNote 4 currentTime :)
        GLFW.Key'P -> atomically $ modifyTVar asPause not
        GLFW.Key'R -> do
          killThread playbackThread
          newThread <- startPlayback logger synth events audioTV pauseTV
          writeIORef asGameplay initialGameplayState
          writeIORef asPlayerInputs []
          writeIORef asHitFeedback []
        _ -> pure ()

  -- In renderFrame, update gameplay
  renderFrame st = do
    currentTime <- readTVarIO asAudioTV
    gs <- readIORef asGameplay
    playerInputs <- readIORef' asPlayerInputs []
    writeIORef asPlayerInputs []

    let pendingNotes = filter (\n -> neTime n > currentTime - hitTolerance && neTime n < currentTime + asPreviewSeconds) events  -- adjust to note events

    let (newGS, newFeedback) = updateGameplay gs currentTime pendingNotes playerInputs
        gsWithMisses = checkMisses newGS currentTime pendingNotes

    writeIORef asGameplay gsWithMisses
    modifyIORef' asHitFeedback (newFeedback ++)

    -- Pass shake to uniform
    glUseProgram asNoteProgram
    shakeLoc <- getUniformLoc asNoteProgram "uShake"
    when (shakeLoc /= -1) $ glUniform1f shakeLoc (realToFrac $ max 0.0 (gsShakeTime gsWithMisses - currentTime) * 10.0)

    -- Render notes as before

    -- Render hit feedback with NanoVG
    NVG.beginFrame asNvgContext (fromIntegral resW) (fromIntegral resH) 1.0
    feedback <- readIORef asHitFeedback
    let activeFeedback = filter (\hf -> hfTime hf > currentTime - 0.3) feedback
    forM_ activeFeedback $ \hf -> do
      let laneWidth = 2.0 / fromIntegral asNumLanes
          x = -1.0 + laneWidth * (fromIntegral (hfLane hf) + 0.5) * (fromIntegral resW / 2.0) + fromIntegral resW / 2.0
          y = fromIntegral resH * 0.95
          radius = 30.0 * (1.0 - realToFrac (currentTime - hfTime hf) / 0.3)
          alpha = 255 * (1.0 - realToFrac (currentTime - hfTime hf) / 0.3)
      NVG.beginPath asNvgContext
      NVG.circle asNvgContext (realToFrac x) (realToFrac y) radius
      NVG.fillColor asNvgContext (NVG.rgba 255 255 0 (round alpha))
      NVG.fill asNvgContext
    writeIORef asHitFeedback activeFeedback

    -- Render score overlay with NanoVG
    NVG.fontFace asNvgContext "regular"
    NVG.fontSize asNvgContext 24.0
    NVG.fillColor asNvgContext (NVG.rgba 255 255 255 255)
    NVG.textAlign asNvgContext (NVG.ALIGN_RIGHT .|. NVG.ALIGN_TOP)
    NVG.text asNvgContext (fromIntegral resW - 20) 20 $ BS8.pack $ "Score: " ++ show (gsScore gsWithMisses)
    NVG.text asNvgContext (fromIntegral resW - 20) 50 $ BS8.pack $ "Combo: " ++ show (gsCombo gsWithMisses)
    NVG.text asNvgContext (fromIntegral resW - 20) 80 $ BS8.pack $ "Accuracy: " ++ printf "%.1f%%" (gsAccuracy gsWithMisses)

    NVG.endFrame asNvgContext

    -- ... other renders (3D, SVG, TUI)

  -- In mainLoop, continue as before

  -- Cleanup: delete driver, synth, settings

  bracket_ (pure ()) (deleteFluidAudioDriver driver >> deleteFluidSynth synth >> deleteFluidSettings settings) $ mainLoop appState

  killThread playbackThread

  -- ... other cleanup